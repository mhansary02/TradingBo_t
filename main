# ================ 0-IMPORTS & SETTINGS ================
import os
import logging
from logging.handlers import RotatingFileHandler
import time
import pandas as pd
import numpy as np
import ccxt
from datetime import datetime, timedelta
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.volatility import BollingerBands, AverageTrueRange
from telegram import Bot, Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import threading
import traceback
import warnings
from typing import Dict, List, Tuple, Optional
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import joblib
import json
import hashlib

warnings.filterwarnings('ignore')

# ================ LOGGER SETUP ================
class AdvancedLogger:
    """Ø³ÛŒØ³ØªÙ… Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ØªØ­Ù„ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø®Ø·Ø§Ù‡Ø§"""
    def __init__(self):
        self.logger = logging.getLogger('CoinExAISwingTrader')
        self.logger.setLevel(logging.DEBUG)
        self.error_patterns = {}
        self.setup_handlers()
        
    def setup_handlers(self):
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s\n'
            'File: %(pathname)s\nFunction: %(funcName)s\nLine: %(lineno)d\n'
            'Message: %(message)s\n'
            '----------------------------------------------------------------------'
        )
        
        # File handler with rotation
        file_handler = RotatingFileHandler(
            'ai_swing_trader.log',
            maxBytes=10*1024*1024,
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        console_handler.setLevel(logging.INFO)
        
        if self.logger.hasHandlers():
            self.logger.handlers.clear()
        
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
    
    def log_error(self, error: Exception, context: str = ""):
        """Ù„Ø§Ú¯ Ú©Ø±Ø¯Ù† Ø®Ø·Ø§ Ø¨Ø§ ØªØ­Ù„ÛŒÙ„ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ"""
        error_hash = hashlib.md5(str(error).encode()).hexdigest()
        self.error_patterns[error_hash] = self.error_patterns.get(error_hash, 0) + 1
        
        log_msg = f"{context} - {str(error)}"
        if self.error_patterns[error_hash] > 3:
            log_msg += f"\nâš ï¸ ØªÙˆØ¬Ù‡: Ø§ÛŒÙ† Ø®Ø·Ø§ {self.error_patterns[error_hash]} Ø¨Ø§Ø± ØªÚ©Ø±Ø§Ø± Ø´Ø¯Ù‡ Ø§Ø³Øª"
        
        self.logger.error(log_msg, exc_info=True)
        
    def get_common_errors(self) -> Dict[str, int]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù¾Ø±ØªÚ©Ø±Ø§Ø±"""
        return {k: v for k, v in sorted(self.error_patterns.items(), key=lambda item: item[1], reverse=True)[:5]}

logger = AdvancedLogger()

# ================ 1-CONFIGURATION ================
class AITraderConfig:
    """ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ"""
    def __init__(self):
        try:
            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØµØ±Ø§ÙÛŒ
            self.EXCHANGE_NAME = 'coinex'
            self.API_KEY = os.getenv('COINEX_API_KEY')
            self.API_SECRET = os.getenv('COINEX_API_SECRET')
            
            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…
            self.TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
            self.TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')
            
            # Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ
            self.SYMBOLS = [
                'BTC/USDT:USDT',
                'ETH/USDT:USDT',
                'BNB/USDT:USDT',
                'SOL/USDT:USDT',
                'ADA/USDT:USDT'
            ]
            
            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†ÙˆØ³Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾ÙˆÛŒØ§
            self.SWING_SETTINGS = {
                'timeframe': '4h',
                'holding_period': '6-24h',
                'target_profit': self._dynamic_target_profit(),
                'max_loss': 1.2,
                'min_volatility': 1.5,
                'risk_per_trade': 1.0,
                'max_daily_trades': 5,
                'leverage': 5,
                'adaptive_mode': True
            }
            
            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙÙ†ÛŒ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ØªØ·Ø¨ÛŒÙ‚
            self.TECHNICAL_INDICATORS = {
                'ema_short': 9,
                'ema_medium': 21,
                'ema_long': 50,
                'rsi_period': 14,
                'stoch_period': 14,
                'macd_fast': 12,
                'macd_slow': 26,
                'macd_signal': 9,
                'bollinger_period': 20,
                'bollinger_std': 2.0,
                'atr_period': 14
            }
            
            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†
            self.ML_SETTINGS = {
                'model_path': 'trading_model.pkl',
                'retrain_interval': 24,  # hours
                'data_points_threshold': 1000,
                'test_size': 0.2
            }
            
            logger.logger.info("AI Configuration loaded successfully")
            
        except Exception as e:
            logger.log_error(e, "Configuration initialization")
            raise
    
    def _dynamic_target_profit(self) -> float:
        """Ù‡Ø¯Ù Ø³ÙˆØ¯ Ù¾ÙˆÛŒØ§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø´Ø±Ø§ÛŒØ· Ø¨Ø§Ø²Ø§Ø±"""
        # Ø¯Ø± Ù†Ø³Ø®Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø§Ø² ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ø§Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯
        return 2.5  # Ù…Ù‚Ø¯Ø§Ø± Ù¾Ø§ÛŒÙ‡
    
    def update_settings_based_on_performance(self, success_rate: float):
        """Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ù…Ù„Ú©Ø±Ø¯"""
        if success_rate < 0.5:
            self.SWING_SETTINGS['target_profit'] *= 0.9
            self.SWING_SETTINGS['risk_per_trade'] *= 0.8
            logger.logger.info(f"Reduced target profit to {self.SWING_SETTINGS['target_profit']}% due to low success rate")
        elif success_rate > 0.7:
            self.SWING_SETTINGS['target_profit'] *= 1.1
            self.SWING_SETTINGS['risk_per_trade'] = min(2.0, self.SWING_SETTINGS['risk_per_trade'] * 1.2)
            logger.logger.info(f"Increased target profit to {self.SWING_SETTINGS['target_profit']}% due to high success rate")

# ================ 2-MACHINE LEARNING MODULE ================
class TradingModel:
    """Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§"""
    def __init__(self, config: AITraderConfig):
        self.config = config
        self.model = None
        self.last_trained = None
        self.load_model()
        
    def load_model(self):
        """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¯Ù„ Ø§Ø² ÙØ§ÛŒÙ„ ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø¯Ù„ Ø¬Ø¯ÛŒØ¯"""
        try:
            if os.path.exists(self.config.ML_SETTINGS['model_path']):
                self.model = joblib.load(self.config.ML_SETTINGS['model_path'])
                self.last_trained = datetime.fromtimestamp(os.path.getmtime(self.config.ML_SETTINGS['model_path']))
                logger.logger.info("Loaded trained model from disk")
            else:
                self.initialize_new_model()
        except Exception as e:
            logger.log_error(e, "Loading trading model")
            self.initialize_new_model()
    
    def initialize_new_model(self):
        """Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ù…Ø¯Ù„ Ø¬Ø¯ÛŒØ¯"""
        self.model = RandomForestClassifier(
            n_estimators=100,
            max_depth=5,
            random_state=42,
            class_weight='balanced'
        )
        self.last_trained = datetime.now()
        logger.log
        # ================ 3-ADVANCED EXCHANGE MANAGER ================
class AIExchangeManager:
    """Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡ ØµØ±Ø§ÙÛŒ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ"""
    def __init__(self, config: AITraderConfig):
        self.config = config
        self.logger = logger.logger.getChild('ExchangeManager')
        self.daily_trades_count = 0
        self.last_trade_time = None
        self.open_positions = {}
        self.trade_history = []
        self.exchange = self._initialize_exchange()
        self._load_trade_history()
        
    def _initialize_exchange(self):
        """Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØµØ±Ø§ÙÛŒ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø¨Ø§Ø²Ø´Ù†Ø§Ø³ÛŒ Ø®Ø·Ø§"""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                exchange = getattr(ccxt, self.config.EXCHANGE_NAME)({
                    'apiKey': self.config.API_KEY,
                    'secret': self.config.API_SECRET,
                    'enableRateLimit': True,
                    'options': {'defaultType': 'future'},
                    'timeout': 10000,
                    'verbose': False
                })
                exchange.load_markets()
                self.logger.info(f"Connected to {self.config.EXCHANGE_NAME} successfully")
                return exchange
            except ccxt.AuthenticationError as e:
                self.logger.error(f"Authentication failed (attempt {attempt+1}/{max_retries}): {str(e)}")
                if attempt == max_retries - 1:
                    raise
                time.sleep(5)
            except ccxt.NetworkError as e:
                self.logger.error(f"Network error (attempt {attempt+1}/{max_retries}): {str(e)}")
                if attempt == max_retries - 1:
                    raise
                time.sleep(10)
            except Exception as e:
                self.logger.error(f"Unexpected error (attempt {attempt+1}/{max_retries}): {str(e)}")
                if attempt == max_retries - 1:
                    raise
                time.sleep(5)

    def _load_trade_history(self):
        """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„"""
        try:
            if os.path.exists('trade_history.json'):
                with open('trade_history.json', 'r') as f:
                    self.trade_history = json.load(f)
                self.logger.info(f"Loaded {len(self.trade_history)} historical trades")
        except Exception as e:
            self.logger.error(f"Error loading trade history: {str(e)}")

    def _save_trade_history(self):
        """Ø°Ø®ÛŒØ±Ù‡ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¯Ø± ÙØ§ÛŒÙ„"""
        try:
            with open('trade_history.json', 'w') as f:
                json.dump(self.trade_history, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving trade history: {str(e)}")

    def get_ohlcv_data(self, symbol: str, timeframe: str = None, limit: int = 200) -> pd.DataFrame:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚ÛŒÙ…Øª Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø®Ø·Ø§"""
        tf = timeframe or self.config.SWING_SETTINGS['timeframe']
        for attempt in range(3):
            try:
                start_time = time.time()
                self.logger.debug(f"Fetching OHLCV for {symbol} (attempt {attempt+1})")
                
                ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe=tf, limit=limit)
                
                if not ohlcv:
                    self.logger.warning(f"No OHLCV data returned for {symbol}")
                    return pd.DataFrame()
                    
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                df.set_index('timestamp', inplace=True)
                
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØºÛŒÛŒØ±Ø§Øª Ù‚ÛŒÙ…Øª Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†
                df['price_change'] = df['close'].pct_change()
                df['target'] = (df['close'].shift(-3) > df['close']).astype(int)  # Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ 3 Ø¯ÙˆØ±Ù‡ Ø¢ÛŒÙ†Ø¯Ù‡
                
                self.logger.debug(f"Fetched {len(df)} records for {symbol} in {time.time()-start_time:.2f}s")
                return df.dropna()
                
            except ccxt.NetworkError as e:
                self.logger.error(f"Network error (attempt {attempt+1}): {str(e)}")
                if attempt == 2:
                    return pd.DataFrame()
                time.sleep(5)
            except Exception as e:
                self.logger.error(f"Unexpected error (attempt {attempt+1}): {str(e)}")
                if attempt == 2:
                    return pd.DataFrame()
                time.sleep(5)

    def execute_trade(self, symbol: str, signal: str, entry: float, 
                     target: float, stop_loss: float, confidence: float,
                     ml_prediction: float = 0.5) -> bool:
        """Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ"""
        trade_id = f"{symbol}-{int(time.time())}"
        trade_details = {
            'id': trade_id,
            'symbol': symbol,
            'direction': signal,
            'entry_price': entry,
            'target_price': target,
            'stop_loss': stop_loss,
            'confidence': confidence,
            'ml_confidence': ml_prediction,
            'status': 'OPEN',
            'entry_time': datetime.now().isoformat()
        }
        
        try:
            # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø±ÙˆØ²Ø§Ù†Ù‡
            if self.daily_trades_count >= self.config.SWING_SETTINGS['max_daily_trades']:
                self.logger.warning(f"Daily trade limit reached ({self.daily_trades_count}/{self.config.SWING_SETTINGS['max_daily_trades']})")
                return False
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ø¯Ø± Ù†Ø¸Ø± Ú¯Ø±ÙØªÙ† Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ø¯Ù„
            adjusted_risk = self.config.SWING_SETTINGS['risk_per_trade'] * confidence * (0.5 + ml_prediction)
            position_size = self.calculate_position_size(entry, stop_loss, adjusted_risk)
            
            if position_size <= 0:
                self.logger.warning("Invalid position size, trade not executed")
                return False
            
            # ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´
            params = {
                'stopLoss': {'stopPrice': stop_loss},
                'takeProfit': {'stopPrice': target},
                'leverage': self.config.SWING_SETTINGS['leverage']
            }
            
            # Ø§Ø¬Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´
            order = self.exchange.create_order(
                symbol=symbol,
                type='limit',
                side='buy' if signal == 'BUY' else 'sell',
                amount=position_size,
                price=entry,
                params=params
            )
            
            # Ø«Ø¨Øª Ù…Ø¹Ø§Ù…Ù„Ù‡
            trade_details.update({
                'size': position_size,
                'order_id': order['id'],
                'order_info': order
            })
            
            self.daily_trades_count += 1
            self.last_trade_time = datetime.now()
            self.open_positions[symbol] = trade_details
            self.trade_history.append(trade_details)
            self._save_trade_history()
            
            self.logger.info(f"Trade executed successfully: {trade_id}")
            return True
            
        except Exception as e:
            trade_details['status'] = 'FAILED'
            trade_details['error'] = str(e)
            self.trade_history.append(trade_details)
            self._save_trade_history()
            
            self.logger.error(f"Failed to execute trade {trade_id}: {str(e)}")
            return False

    def calculate_position_size(self, entry: float, stop_loss: float, risk_percent: float) -> float:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú© Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
        try:
            balance = self.get_balance()
            if balance <= 0:
                self.logger.warning(f"Insufficient balance: {balance}")
                return 0.0
                
            risk_amount = balance * (risk_percent / 100)
            risk_per_unit = abs(entry - stop_loss)
            
            if risk_per_unit == 0:
                self.logger.error("Zero risk per unit (entry == stop_loss)")
                return 0.0
                
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø§ Ø¯Ø± Ù†Ø¸Ø± Ú¯Ø±ÙØªÙ† Ù„ÙˆØ±ÛŒØ¬ Ùˆ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØµØ±Ø§ÙÛŒ
            position_size = (risk_amount / risk_per_unit) * self.config.SWING_SETTINGS['leverage']
            
            # Ú¯Ø±Ø¯ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„ Ø¨Ø±Ø§ÛŒ ØµØ±Ø§ÙÛŒ
            symbol_info = self.exchange.market(self.config.SYMBOLS[0])  # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÙˆÙ„ÛŒÙ† Ù†Ù…Ø§Ø¯ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù†Ù…ÙˆÙ†Ù‡
            if 'precision' in symbol_info and 'amount' in symbol_info['precision']:
                precision = symbol_info['precision']['amount']
                position_size = round(position_size, precision)
                
  def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ"""
    try:
        if df.empty:
            self.logger.warning("Empty DataFrame received")
            return df
            
        # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ø´ Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¹Ù…Ù„Ú©Ø±Ø¯
        cache_key = hashlib.md5(pd.util.hash_pandas_object(df).values).hexdigest()
        if cache_key in self.indicators_cache:
            return self.indicators_cache[cache_key]
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA
        df['ema_short'] = self._calculate_ema(df, 'close', self.config.TECHNICAL_INDICATORS['ema_short'])
        df['ema_medium'] = self._calculate_ema(df, 'close', self.config.TECHNICAL_INDICATORS['ema_medium'])
        df['ema_long'] = self._calculate_ema(df, 'close', self.config.TECHNICAL_INDICATORS['ema_long'])
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD
        df['macd'], df['macd_signal'], df['macd_diff'] = self._calculate_macd(df)
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI
        df['rsi'] = RSIIndicator(
            df['close'],
            window=self.config.TECHNICAL_INDICATORS['rsi_period']
        ).rsi()
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Stochastic
        df['stoch_k'], df['stoch_d'] = self._calculate_stochastic(df)
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Bollinger Bands
        df['bb_upper'], df['bb_middle'], df['bb_lower'] = self._calculate_bollinger(df)
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ ATR
        df['atr'] = AverageTrueRange(
            high=df['high'],
            low=df['low'],
            close=df['close'],
            window=self.config.TECHNICAL_INDICATORS['atr_period']
        ).average_true_range()
        
        # ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†
        df['price_change_5'] = df['close'].pct_change(5)
        df['volume_change'] = df['volume'].pct_change()
        df['volatility'] = df['close'].rolling(5).std() / df['close'].rolling(5).mean()
        
        self.indicators_cache[cache_key] = df.dropna()
        return self.indicators_cache[cache_key]
        
    except Exception as e:
        self.logger.error(f"Error in calculate_indicators: {str(e)}")
        return df

def _calculate_ema(self, df: pd.DataFrame, column: str, window: int) -> pd.Series:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø¨Ø§ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ"""
    return EMAIndicator(df[column], window=window).ema_indicator()

def _calculate_macd(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD"""
    macd = MACD(
        df['close'],
        window_slow=self.config.TECHNICAL_INDICATORS['macd_slow'],
        window_fast=self.config.TECHNICAL_INDICATORS['macd_fast'],
        window_sign=self.config.TECHNICAL_INDICATORS['macd_signal']
    )
    return macd.macd(), macd.macd_signal(), macd.macd_diff()

def _calculate_stochastic(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series]:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Stochastic"""
    stoch = StochasticOscillator(
        high=df['high'],
        low=df['low'],
        close=df['close'],
        window=self.config.TECHNICAL_INDICATORS['stoch_period']
    )
    return stoch.stoch(), stoch.stoch_signal()

def _calculate_bollinger(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Bollinger Bands"""
    bb = BollingerBands(
        df['close'],
        window=self.config.TECHNICAL_INDICATORS['bollinger_period'],
        window_dev=self.config.TECHNICAL_INDICATORS['bollinger_std']
    )
    return bb.bollinger_hband(), bb.bollinger_mavg(), bb.bollinger_lband()

def generate_signal(self, df: pd.DataFrame) -> dict:
    """ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ùˆ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†"""
    signal = {
        'direction': None,
        'entry': None,
        'target': None,
        'stop_loss': None,
        'confidence': 0.0,
        'ml_confidence': 0.0
    }
    
    try:
        if len(df) < 50:  # Ø­Ø¯Ø§Ù‚Ù„ Ø¯Ø§Ø¯Ù‡ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²
            self.logger.warning("Insufficient data for signal generation")
            return signal
            
        last_row = df.iloc[-1]
        prev_row = df.iloc[-2]
        
        # Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†
        ml_features = self._prepare_ml_features(df)
        ml_prediction = self.model.predict_proba(ml_features)[0][1]
        signal['ml_confidence'] = ml_prediction
        
        # Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÛŒØ¯ ØªØ±Ú©ÛŒØ¨ÛŒ
        buy_conditions = (
            (last_row['ema_short'] > last_row['ema_long']) and
            (last_row['rsi'] < 45) and
            (last_row['macd'] > last_row['macd_signal']) and
            (last_row['close'] < last_row['bb_lower'] + (0.5 * last_row['atr'])) and
            (last_row['volume'] > df['volume'].rolling(5).mean().iloc[-1]) and
            (ml_prediction > 0.6)
        )
        
        # Ø´Ø±Ø§ÛŒØ· ÙØ±ÙˆØ´ ØªØ±Ú©ÛŒØ¨ÛŒ
        sell_conditions = (
            (last_row['ema_short'] < last_row['ema_long']) and
            (last_row['rsi'] > 55) and
            (last_row['macd'] < last_row['macd_signal']) and
            (last_row['close'] > last_row['bb_upper'] - (0.5 * last_row['atr'])) and
            (last_row['volume'] > df['volume'].rolling(5).mean().iloc[-1]) and
            (ml_prediction < 0.4)
        )
        
        if buy_conditions:
            confidence = min(0.9, (45 - last_row['rsi']) / 45 * 0.6 + ml_prediction * 0.4)
            signal.update({
                'direction': 'BUY',
                'entry': last_row['close'],
                'target': self._calculate_target(last_row['close'], 'BUY'),
                'stop_loss': self._calculate_stop_loss(last_row['close'], last_row['atr'], 'BUY'),
                'confidence': confidence
            })
            
        elif sell_conditions:
            confidence = min(0.9, (last_row['rsi'] - 55) / 45 * 0.6 + (1 - ml_prediction) * 0.4)
            signal.update({
                'direction': 'SELL',
                'entry': last_row['close'],
                'target': self._calculate_target(last_row['close'], 'SELL'),
                'stop_loss': self._calculate_stop_loss(last_row['close'], last_row['atr'], 'SELL'),
                'confidence': confidence
            })
            
        self.logger.debug(f"Generated signal: {signal}")
        return signal
        
    except Exception as e:
        self.logger.error(f"Error in generate_signal: {str(e)}")
        return signal

def _prepare_ml_features(self, df: pd.DataFrame) -> pd.DataFrame:
    """Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†"""
    features = df[[
        'ema_short', 'ema_medium', 'ema_long',
        'macd', 'macd_signal', 'macd_diff',
        'rsi', 'stoch_k', 'stoch_d',
        'bb_upper', 'bb_middle', 'bb_lower',
        'atr', 'price_change_5', 'volume_change', 'volatility'
    ]].iloc[-1:].copy()
    
    # Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§
    for col in features.columns:
        if df[col].std() > 0:
            features[col] = (features[




Ø¨Ù‚ÛŒÙ‡ Ú©Ø¯ Ø±Ø§ Ù†Ø´Ø§Ù† Ø¨Ø¯Ù‡

================ 5-TELEGRAM BOT MANAGER ================
class AdvancedTelegramManager:
"""Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒØ¯Ù‡ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯"""
def init(self, config: AITraderConfig, exchange_manager: AIExchangeManager):
self.config = config
self.exchange = exchange_manager
self.logger = logger.logger.getChild('TelegramManager')
self.bot = None
self.application = None
self._initialize_bot()

def _initialize_bot(self):
    """Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§"""
    try:
        self.bot = Bot(token=self.config.TELEGRAM_TOKEN)
        self.application = Application.builder().token(self.config.TELEGRAM_TOKEN).build()
        
        # Ø«Ø¨Øª Ø¯Ø³ØªÙˆØ±Ø§Øª
        handlers = [
            CommandHandler("start", self._command_start),
            CommandHandler("stop", self._command_stop),
            CommandHandler("status", self._command_status),
            CommandHandler("positions", self._command_positions),
            CommandHandler("balance", self._command_balance),
            CommandHandler("performance", self._command_performance),
            CommandHandler("errors", self._command_errors),
            CommandHandler("settings", self._command_settings),
            CommandHandler("prices", self._command_prices),
            MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message)
        ]
        
        for handler in handlers:
            self.application.add_handler(handler)
        
        # Ø´Ø±ÙˆØ¹ Ø¨Ø§Øª Ø¯Ø± ÛŒÚ© thread Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡
        self.bot_thread = threading.Thread(target=self._run_bot, daemon=True)
        self.bot_thread.start()
        
        self.logger.info("Telegram bot initialized successfully")
        
    except Exception as e:
        self.logger.error(f"Failed to initialize Telegram bot: {str(e)}")
        raise

def _run_bot(self):
    """Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Øª Ø¯Ø± thread Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡"""
    try:
        self.application.run_polling(
            poll_interval=0.5,
            timeout=10,
            bootstrap_retries=-1,
            allowed_updates=Update.ALL_TYPES
        )
    except Exception as e:
        self.logger.error(f"Error in bot polling: {str(e)}")

async def _command_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø³ØªÙˆØ± Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª"""
    try:
        await update.message.reply_text(
            "ğŸ¤– Ø±Ø¨Ø§Øª Ù†ÙˆØ³Ø§Ù†â€ŒÚ¯ÛŒØ± Ù‡ÙˆØ´Ù…Ù†Ø¯ ÙØ¹Ø§Ù„ Ø´Ø¯\n\n"
            "ğŸ”¹ Ø¯Ø³ØªÙˆØ±Ø§Øª Ù…ÙˆØ¬ÙˆØ¯:\n"
            "/status - ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ\n"
            "/positions - Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²\n"
            "/balance - Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø­Ø³Ø§Ø¨\n"
            "/performance - Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª\n"
            "/errors - Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ±\n"
            "/settings - ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙØ¹Ù„ÛŒ\n"
            "/prices - Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±\n"
            "/stop - ØªÙˆÙ‚Ù Ø±Ø¨Ø§Øª\n\n"
            "ğŸ”„ Ù†Ø³Ø®Ù‡: AI Trading Bot 2.0"
        )
    except Exception as e:
        self.logger.error(f"Error in /start command: {str(e)}")

async def _command_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ø³ÛŒØ³ØªÙ…"""
    try:
        status = self._get_system_status()
        await update.message.reply_text(status, parse_mode='Markdown')
    except Exception as e:
        self.logger.error(f"Error in /status command: {str(e)}")
        await update.message.reply_text("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…")

def _get_system_status(self) -> str:
    """ØªÙ‡ÛŒÙ‡ Ú¯Ø²Ø§Ø±Ø´ ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…"""
    balance = self.exchange.get_balance()
    positions = len(self.exchange.open_positions)
    daily_trades = self.exchange.daily_trades_count
    last_trade = self.exchange.last_trade_time.strftime('%Y-%m-%d %H:%M') if self.exchange.last_trade_time else "None"
    
    return (
        "ğŸ“Š *ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…*\n\n"
        f"â€¢ ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {balance:.2f} USDT\n"
        f"â€¢ ğŸ“Œ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²: {positions}\n"
        f"â€¢ ğŸ”„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù…Ø±ÙˆØ²: {daily_trades}/{self.config.SWING_SETTINGS['max_daily_trades']}\n"
        f"â€¢ â± Ø¢Ø®Ø±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: {last_trade}\n"
        f"â€¢ ğŸš¦ Ø­Ø§Ù„Øª ØªØ·Ø¨ÛŒÙ‚ÛŒ: {'ÙØ¹Ø§Ù„' if self.config.SWING_SETTINGS['adaptive_mode'] else 'ØºÛŒØ±ÙØ¹Ø§Ù„'}\n"
        f"â€¢ ğŸ“ˆ Ø§Ø¹ØªÙ…Ø§Ø¯ Ù…Ø¯Ù„ AI: {self.exchange.get_model_confidence()*100:.1f}%"
    )

async def _command_positions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²"""
    try:
        positions = self._format_positions()
        await update.message.reply_text(positions, parse_mode='Markdown')
    except Exception as e:
        self.logger.error(f"Error in /positions command: {str(e)}")
        await update.message.reply_text("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§")

def _format_positions(self) -> str:
    """ÙØ±Ù…Øªâ€ŒØ¯Ù‡ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²"""
    if not self.exchange.open_positions:
        return "ğŸ“­ Ù‡ÛŒÚ† Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯"
        
    positions_text = "ğŸ“‹ *Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²*\n\n"
    for symbol, pos in self.exchange.open_positions.items():
        pnl = ((pos['current_price'] - pos['entry_price']) / pos['entry_price']) * 100 * (
            1 if pos['direction'] == 'BUY' else -1
        )
        positions_text += (
            f"â€¢ *{symbol}* ({'Ø®Ø±ÛŒØ¯' if pos['direction'] == 'BUY' else 'ÙØ±ÙˆØ´'})\n"
            f"  â± ÙˆØ±ÙˆØ¯: {pos['entry_price']:.4f}\n"
            f"  ğŸ¯ Ù‡Ø¯Ù: {pos['target_price']:.4f}\n"
            f"  ğŸ›‘ Ø­Ø¯ Ø¶Ø±Ø±: {pos['stop_loss']:.4f}\n"
            f"  ğŸ“Š Ø³ÙˆØ¯/Ø¶Ø±Ø±: {pnl:.2f}%\n"
            f"  â³ Ø²Ù…Ø§Ù†: {pos['entry_time']}\n\n"
        )
    return positions_text

async def _command_performance(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª"""
    try:
        performance = self._calculate_performance()
        await update.message.reply_text(performance, parse_mode='Markdown')
    except Exception as e:
        self.logger.error(f"Error in /performance command: {str(e)}")
        await update.message.reply_text("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¹Ù…Ù„Ú©Ø±Ø¯")

def _calculate_performance(self) -> str:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    if not self.exchange.trade_history:
        return "ğŸ“Š Ù‡ÛŒÚ† ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯"
        
    total_trades = len(self.exchange.trade_history)
    winning_trades = sum(1 for t in self.exchange.trade_history if t.get('pnl', 0) > 0)
    win_rate = (winning_trades / total_trades) * 100 if total_trades > 0 else 0
    total_pnl = sum(t.get('pnl', 0) for t in self.exchange.trade_history)
    
    return (
        "ğŸ“ˆ *Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ*\n\n"
        f"â€¢ ğŸ”¢ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {total_trades}\n"
        f"â€¢ âœ… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø³ÙˆØ¯Ø¯Ù‡: {winning_trades} ({win_rate:.1f}%)\n"
        f"â€¢ ğŸ’µ Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ: {total_pnl:.2f} USDT\n"
        f"â€¢ ğŸ“Š Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: {max(t.get('pnl', 0) for t in self.exchange.trade_history):.2f} USDT\n"
        f"â€¢ ğŸ“‰ Ø¨Ø¯ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: {min(t.get('pnl', 0) for t in self.exchange.trade_history):.2f} USDT"
    )

def send_alert(self, message: str, urgent: bool = False):
    """Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø³Ø·ÙˆØ­ Ø§Ù‡Ù…ÛŒØª Ù…Ø®ØªÙ„Ù"""
    try:
        if urgent:
            message = "ğŸš¨ " + message
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø± thread Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² blocking
        threading.Thread(
            target=self._send_message_sync,
            args=(message,),
            daemon=True
        ).start()
    except Exception as e:
        self.logger.error(f"Error sending alert: {str(e)}")

def _send_message_sync(self, message: str):
    """Ø§Ø±Ø³Ø§Ù„ Ù‡Ù…Ø²Ù…Ø§Ù† Ù¾ÛŒØ§Ù…"""
    try:
        self.bot.send_message(
            chat_id=self.config.TELEGRAM_CHAT_ID,
            text=message,
            parse_mode='Markdown'
        # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øªâ€ŒÙ‡Ø§
        self.config = AITraderConfig()
        self.model = TradingModel(self.config)
        self.exchange = AIExchangeManager(self.config)
        self.analyzer = AITechnicalAnalyzer(self.config, self.model)
        self.telegram = AdvancedTelegramManager(self.config, self.exchange)
        
        # Ø«Ø¨Øª Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ
        self.emergency_handlers = {
            'high_loss': self._handle_high_loss,
            'connection_lost': self._handle_connection_issue,
            'market_crash': self._handle_market_crash
        }
        
        self.logger.info("AI Trading Bot initialized successfully")
        
    except Exception as e:
        self.logger.error(f"Failed to initialize trading bot: {str(e)}")
        raise

def start(self):
    """Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    self.running = True
    self.logger.info("=== Starting AI Trading Bot ===")
    self.telegram.send_alert("ğŸš€ Ø±Ø¨Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø´Ø±ÙˆØ¹ Ø¨Ù‡ Ú©Ø§Ø± Ú©Ø±Ø¯")
    
    try:
        while self.running:
            try:
                # Ø¨Ø±Ø±Ø³ÛŒ Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ù…Ø¯Ù„
                if self._should_retrain_model():
                    self._retrain_model()
                
                # Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ ÙØ±ØµØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ
                self.scan_market()
                
                # Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²
                self.manage_positions()
                
                # Ø®ÙˆØ§Ø¨ Ø¨ÛŒÙ† Ú†Ø±Ø®Ù‡â€ŒÙ‡Ø§
                time.sleep(self.trade_interval)
                
            except KeyboardInterrupt:
                self.logger.info("Bot stopped by user")
                self.telegram.send_alert("ğŸ›‘ Ø±Ø¨Ø§Øª ØªÙˆØ³Ø· Ú©Ø§Ø±Ø¨Ø± Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
                break
            except Exception as e:
                self.logger.error(f"Error in main loop: {str(e)}")
                time.sleep(60)  # ØªÙˆÙ‚Ù Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
                
    except Exception as e:
        self.logger.critical(f"Fatal error: {str(e)}")
        self.telegram.send_alert(f"â˜ ï¸ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ: Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯\n{str(e)}")
    finally:
        self.running = False
        self.logger.info("Trading bot stopped")

def _should_retrain_model(self) -> bool:
    """ØªØ¹ÛŒÛŒÙ† Ø¢ÛŒØ§ Ù…Ø¯Ù„ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ø¯Ø§Ø±Ø¯"""
    if not self.last_retrain_time:
        return True
        
    hours_since_last = (datetime.now() - self.last_retrain_time).total_seconds() / 3600
    return hours_since_last >= self.config.ML_SETTINGS['retrain_interval']

def _retrain_model(self):
    """Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†"""
    try:
        self.logger.info("Starting model retraining...")
        self.telegram.send_alert("ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ù…Ø¯Ù„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...")
        
        # Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ
        all_data = []
        for symbol in self.config.SYMBOLS:
            df = self.exchange.get_ohlcv_data(symbol, limit=500)
            if not df.empty:
                all_data.append(df)
        
        if not all_data:
            self.logger.warning("No data available for retraining")
            return
            
        combined_df = pd.concat(all_data)
        X = combined_df.drop(columns=['target'], errors='ignore')
        y = combined_df['target']
        
        # ØªÙ‚Ø³ÛŒÙ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, 
            test_size=self.config.ML_SETTINGS['test_size'],
            random_state=42
        )
        
        # Ø¢Ù…ÙˆØ²Ø´ Ù…Ø¯Ù„
        self.model.train(X_train, y_train)
        
        # Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…Ø¯Ù„
        accuracy = self.model.evaluate(X_test, y_test)
        self.last_retrain_time = datetime.now()
        
        self.telegram.send_alert(
            f"âœ… Ù…Ø¯Ù„ Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ø´Ø¯\n"
            f"Ø¯Ù‚Øª Ù…Ø¯Ù„: {accuracy*100:.1f}%\n"
            f"ØªØ¹Ø¯Ø§Ø¯ Ù†Ù…ÙˆÙ†Ù‡â€ŒÙ‡Ø§: {len(combined_df)}"
        )
        self.logger.info(f"Model retrained successfully. Accuracy: {accuracy:.2f}")
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù…Ø¯Ù„
        self._update_trading_strategy(accuracy)
        
    except Exception as e:
        self.logger.error(f"Model retraining failed: {str(e)}")
        self.telegram.send_alert("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ Ù…Ø¯Ù„")

def _update_trading_strategy(self, model_accuracy: float):
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¯Ù‚Øª Ù…Ø¯Ù„"""
    try:
        if model_accuracy > 0.7:
            self.config.SWING_SETTINGS['risk_per_trade'] = min(
                2.0, 
                self.config.SWING_SETTINGS['risk_per_trade'] * 1.2
            )
            self.config.SWING_SETTINGS['target_profit'] *= 1.1
        elif model_accuracy < 0.5:
            self.config.SWING_SETTINGS['risk_per_trade'] *= 0.8
            self.config.SWING_SETTINGS['target_profit'] *= 0.9
            
        self.logger.info(
            f"Updated strategy based on model accuracy ({model_accuracy:.2f}): "
            f"Risk: {self.config.SWING_SETTINGS['risk_per_trade']}%, "
            f"Target: {self.config.SWING_SETTINGS['target_profit']}%"
        )
    except Exception as e:
        self.logger.error(f"Error updating trading strategy: {str(e)}")

def scan_market(self):
    """Ø§Ø³Ú©Ù† Ø¨Ø§Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† ÙØ±ØµØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    self.logger.info("Starting market scan...")
    
    try:
        for symbol in self.config.SYMBOLS:
            if not self.running:
                break
                
            if self.exchange.daily_trades_count >= self.config.SWING_SETTINGS['max_daily_trades']:
                self.logger.info("Daily trade limit reached")
                break
                
            if symbol in self.exchange.open_positions:
                continue
                
            # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
            df = self.exchange.get_ohlcv_data(symbol)
            if df.empty:
                continue
                
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
            df = self.analyzer.calculate_indicators(df)
            
            # ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„
            signal = self.analyzer.generate_signal(df)
            
            # Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù‚ÙˆÛŒ
            if signal['direction'] and signal['confidence'] >= 0.7:
                self.logger.info(f"Executing trade for {symbol}: {signal}")
                self.exchange.execute_trade(
                    symbol=symbol,
                    signal=signal['direction'],
                    entry=signal['entry'],
                    target=signal['target'],
                    stop_loss=signal['stop_loss'],
                    confidence=signal['confidence'],
                    ml_prediction=signal['ml_confidence']
                )
                
                # ØªÙˆÙ‚Ù Ú©ÙˆØªØ§Ù‡ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² rate limit
                time.sleep(2)
                
    except Exception as e:
        self.logger.error(f"Market scan failed: {str(e)}")
        self.handle_emergency('connection_lost')

def manage_positions(self):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²"""
    self.logger.debug("Managing open positions...")
    
    try:
        for symbol, position in list(self.exchange.open_positions.items()):
            if not self.running:
                break
                
            try:
                # Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
                ticker = self.exchange.exchange.fetch_ticker(symbol)
                current_price = ticker['last']
                self.exchange.open_positions[symbol]['current_price'] = current_price
                
                # Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÙˆØ¬
                exit_condition = self._check_exit_conditions(symbol, position, current_price)
                if exit_condition:
                    self._close_position(symbol, exit_condition)
                    
            except Exception as e:
                self.logger.error(f"Error managing position {symbol}: {str(e)}")
                continue
                
    except Exception as e:
        self.logger.error(f"Position management failed: {str(e)}")

def _check_exit_conditions(self, symbol: str, position: dict, current_price: float) -> Optional[str]:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡"""
    # Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯ Ø³ÙˆØ¯
    if position['direction'] == 'BUY' and current_price >= position['target_price']
def _check_exit_conditions(self, symbol: str, position: dict, current_price: float) -> Optional[str]:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ù…Ù†Ø·Ù‚ Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
    try:
        direction = position['direction']
        entry_price = position['entry_price']
        target_price = position['target_price']
        stop_loss = position['stop_loss']
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† ÙØ¹Ù„ÛŒ
        pnl = ((current_price - entry_price) / entry_price) * 100 * (1 if direction == 'BUY' else -1)
        
        # 1. Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÙˆÛŒØ§
        if self._check_dynamic_stop_loss(position, current_price, pnl):
            return "Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÙˆÛŒØ§ ÙØ¹Ø§Ù„ Ø´Ø¯"
            
        # 2. Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯ Ø³ÙˆØ¯
        if (direction == 'BUY' and current_price >= target_price) or \
           (direction == 'SELL' and current_price <= target_price):
            return "Ø­Ø¯ Ø³ÙˆØ¯ ÙØ¹Ø§Ù„ Ø´Ø¯"
            
        # 3. Ø¨Ø±Ø±Ø³ÛŒ Ø²Ù…Ø§Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ
        hold_time = datetime.now() - datetime.fromisoformat(position['entry_time'])
        max_hold = timedelta(hours=24)
        if hold_time > max_hold:
            return "Ø²Ù…Ø§Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯"
            
        # 4. Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±
        if self._check_market_conditions(symbol, current_price):
            return "Ø´Ø±Ø§ÛŒØ· Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±"
            
        # 5. Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹Ú©ÙˆØ³ Ø§Ø² Ù…Ø¯Ù„ AI
        if self._check_ai_reversal_signal(symbol):
            return "Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹Ú©ÙˆØ³ AI"
            
        return None
            
    except Exception as e:
        self.logger.error(f"Error in exit condition check: {str(e)}")
        return None

def _check_dynamic_stop_loss(self, position: dict, current_price: float, pnl: float) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÙˆÛŒØ§ Ø¨Ø§ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾"""
    direction = position['direction']
    stop_loss = position['stop_loss']
    
    # Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø®Ø±ÛŒØ¯
    if direction == 'BUY':
        # Ø§Ú¯Ø± Ù‚ÛŒÙ…Øª 50% Ø§Ø² Ù‡Ø¯Ù Ú¯Ø°Ø± Ú©Ø±Ø¯Ù‡ØŒ Ø§Ø³ØªØ§Ù¾ Ø±Ø§ Ø¨Ù‡ Ù†Ù‚Ø·Ù‡ Ø³Ø±Ø¨Ù‡â€ŒØ³Ø± Ù…Ù†ØªÙ‚Ù„ Ú©Ù†
        if current_price >= position['entry_price'] + (position['target_price'] - position['entry_price']) * 0.5:
            new_stop = position['entry_price'] * 1.005  # Ú©Ù…ÛŒ Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² Ù†Ù‚Ø·Ù‡ ÙˆØ±ÙˆØ¯
            if new_stop > stop_loss:
                position['stop_loss'] = new_stop
                self.logger.info(f"Updated trailing stop for {position['symbol']} to {new_stop:.4f}")
        
        return current_price <= position['stop_loss']
    
    # Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ ÙØ±ÙˆØ´
    else:
        if current_price <= position['entry_price'] - (position['entry_price'] - position['target_price']) * 0.5:
            new_stop = position['entry_price'] * 0.995  # Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ù†Ù‚Ø·Ù‡ ÙˆØ±ÙˆØ¯
            if new_stop < stop_loss:
                position['stop_loss'] = new_stop
                self.logger.info(f"Updated trailing stop for {position['symbol']} to {new_stop:.4f}")
        
        return current_price >= position['stop_loss']

def _check_market_conditions(self, symbol: str, current_price: float) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· Ø®Ø§Øµ Ø¨Ø§Ø²Ø§Ø±"""
    try:
        # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
        ticker = self.exchange.exchange.fetch_ticker(symbol)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ÙˆØ³Ø§Ù† ØºÛŒØ±Ø¹Ø§Ø¯ÛŒ
        price_change_24h = ticker['percentage']
        if abs(price_change_24h) > 15:  # ØªØºÛŒÛŒØ± Ø¨ÛŒØ´ Ø§Ø² 15% Ø¯Ø± 24 Ø³Ø§Ø¹Øª
            self.logger.warning(f"Abnormal volatility detected for {symbol}: {price_change_24h:.2f}%")
            return True
            
        # Ø¨Ø±Ø±Ø³ÛŒ Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª ØºÛŒØ±Ø¹Ø§Ø¯ÛŒ
        avg_volume = self.exchange.get_avg_volume(symbol, period=30)
        current_volume = ticker['baseVolume']
        
        if current_volume > avg_volume * 5:  # Ø­Ø¬Ù… 5 Ø¨Ø±Ø§Ø¨Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù…Ø§Ù‡Ø§Ù†Ù‡
            self.logger.warning(f"Abnormal volume detected for {symbol}: {current_volume:.2f} vs avg {avg_volume:.2f}")
            return True
            
        return False
        
    except Exception as e:
        self.logger.error(f"Error checking market conditions: {str(e)}")
        return False

def _check_ai_reversal_signal(self, symbol: str) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹Ú©ÙˆØ³ Ø§Ø² Ù…Ø¯Ù„ AI"""
    try:
        df = self.exchange.get_ohlcv_data(symbol)
        if df.empty:
            return False
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
        df = self.analyzer.calculate_indicators(df)
        
        # Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ø¯Ù„
        prediction = self.analyzer.get_ai_prediction(df)
        
        # Ø§Ú¯Ø± Ù…Ø¯Ù„ Ø¨Ø§ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø¨Ø§Ù„Ø§ (>70%) Ø®Ù„Ø§Ù Ù…ÙˆÙ‚Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ú©Ù†Ø¯
        current_position = self.exchange.open_positions.get(symbol, {}).get('direction')
        if current_position == 'BUY' and prediction < 0.3:
            return True
        elif current_position == 'SELL' and prediction > 0.7:
            return True
            
        return False
        
    except Exception as e:
        self.logger.error(f"Error checking AI reversal signal: {str(e)}")
        return False

def _close_position(self, symbol: str, reason: str):
    """Ø¨Ø³ØªÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
    try:
        self.logger.info(f"Closing position for {symbol}, reason: {reason}")
        
        # Ø¨Ø³ØªÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø± ØµØ±Ø§ÙÛŒ
        success = self.exchange.close_position(symbol)
        if not success:
            raise Exception("Failed to close position on exchange")
            
        # Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬ Ù…Ø¹Ø§Ù…Ù„Ù‡
        position = self.exchange.open_positions.pop(symbol)
        entry_price = position['entry_price']
        exit_price = position.get('current_price', position['target_price'])
        pnl = ((exit_price - entry_price) / entry_price) * 100 * (1 if position['direction'] == 'BUY' else -1)
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª
        trade_result = {
            'symbol': symbol,
            'direction': position['direction'],
            'entry_price': entry_price,
            'exit_price': exit_price,
            'pnl': pnl,
            'duration': str(datetime.now() - datetime.fromisoformat(position['entry_time'])),
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        }
        
        self.exchange.trade_history.append(trade_result)
        self.exchange.save_trade_history()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        self.telegram.send_alert(
            f"ğŸ”š Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯\n\n"
            f"â€¢ Ù†Ù…Ø§Ø¯: {symbol}\n"
            f"â€¢ Ù†ÙˆØ¹: {'Ø®Ø±ÛŒØ¯' if position['direction'] == 'BUY' else 'ÙØ±ÙˆØ´'}\n"
            f"â€¢ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {entry_price:.4f}\n"
            f"â€¢ Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬: {exit_price:.4f}\n"
            f"â€¢ Ø³ÙˆØ¯/Ø¶Ø±Ø±: {pnl:.2f}%\n"
            f"â€¢ Ù…Ø¯Øª: {trade_result['duration']}\n"
            f"â€¢ Ø¯Ù„ÛŒÙ„: {reason}"
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ØªÛŒØ¬Ù‡
        self._update_strategy_based_on_trade(trade_result)
        
    except Exception as e:
        self.logger.error(f"Error closing position: {str(e)}")
        self.telegram.send_alert(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø³ØªÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡ {symbol}: {str(e)}")

def _update_strategy_based_on_trade(self, trade_result: dict):
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ØªÛŒØ¬Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡"""
    try:
        # ÙÙ‚Ø· Ø§Ú¯Ø± Ø¶Ø±Ø± Ø¨ÛŒØ´ Ø§Ø² 2% Ø¨ÙˆØ¯
        if trade_result['pnl'] < -2:
            # Ú©Ø§Ù‡Ø´ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø¹Ø¯ÛŒ
            self.config.SWING_SETTINGS['risk_per_trade'] = max(
                0.5, 
                self.config.SWING_SETTINGS['risk_per_trade'] * 0.9
            )
            self.logger.info(f"Reduced risk per trade to {self.config.SWING_SETTINGS['risk_per_trade']}% due to loss")
            
            # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ù„ÛŒØ³Øª Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø¶Ø¹ÛŒÙ
            self.model.add_weak_signal(trade_result['symbol'], trade_result['direction'])
            
        # Ø§Ú¯Ø± Ø³ÙˆØ¯ Ø¨ÛŒØ´ Ø§Ø² 5% Ø¨ÙˆØ¯
        elif trade_result['pnl'] > 5:
            # Ø§ÙØ²Ø§ÛŒØ´ ØªØ¯Ø±ÛŒØ¬ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù…ÙˆÙ‚Ø¹
            
def handle_emergency(self, emergency_type: str, **kwargs):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø´Ø±Ø§ÛŒØ· Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ù…Ø®ØªÙ„Ù"""
    try:
        handler = self.bot.emergency_handlers.get(emergency_type)
        if handler:
            handler(**kwargs)
        else:
            self.logger.warning(f"No handler found for emergency type: {emergency_type}")
            
    except Exception as e:
        self.logger.error(f"Error handling emergency: {str(e)}")
        self.bot.telegram.send_alert(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø¯ÛŒØ±ÛŒØª Ø´Ø±Ø§ÛŒØ· Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ: {str(e)}")

def _handle_high_loss(self, threshold: float = -5.0):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø¶Ø±Ø±Ù‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†"""
    try:
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¶Ø±Ø±Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ±
        recent_trades = [t for t in self.bot.exchange.trade_history 
                       if datetime.now() - datetime.fromisoformat(t['timestamp']) < timedelta(days=1)]
        
        if not recent_trades:
            return
            
        loss_count = sum(1 for t in recent_trades if t['pnl'] < threshold)
        total_trades = len(recent_trades)
        
        if loss_count >= 3 and (loss_count / total_trades) > 0.5:
            # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ø­ÙØ§Ø¸ØªÛŒ
            self.bot.config.SWING_SETTINGS['risk_per_trade'] = max(
                0.5, 
                self.bot.config.SWING_SETTINGS['risk_per_trade'] * 0.7
            )
            
            self.logger.warning(
                f"High loss detected! {loss_count}/{total_trades} trades below {threshold}%. "
                f"Reduced risk to {self.bot.config.SWING_SETTINGS['risk_per_trade']}%"
            )
            
            self.bot.telegram.send_alert(
                f"ğŸš¨ Ø­Ø§Ù„Øª Ø­ÙØ§Ø¸ØªÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯\n\n"
                f"â€¢ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¶Ø±Ø±Ø¯Ù‡ Ø§Ø®ÛŒØ±: {loss_count}\n"
                f"â€¢ Ø¯Ø±ØµØ¯ Ø¶Ø±Ø±: Ø¨ÛŒØ´ Ø§Ø² {threshold}%\n"
                f"â€¢ Ø±ÛŒØ³Ú© Ø¬Ø¯ÛŒØ¯ Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡: {self.bot.config.SWING_SETTINGS['risk_per_trade']}%\n\n"
                f"Ø±Ø¨Ø§Øª Ø¨Ù‡ Ø·ÙˆØ± Ù…ÙˆÙ‚Øª Ø±ÛŒØ³Ú© Ø±Ø§ Ú©Ø§Ù‡Ø´ Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª"
            )
            
            # Ø¨Ø§Ø²Ø¢Ù…ÙˆØ²ÛŒ ÙÙˆØ±ÛŒ Ù…Ø¯Ù„
            self.bot._retrain_model()
            
    except Exception as e:
        self.logger.error(f"Error in high loss handling: {str(e)}")

def _handle_connection_issue(self, retry_count: int = 3):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø´Ú©Ù„Ø§Øª Ø§ØªØµØ§Ù„"""
    try:
        for attempt in range(retry_count):
            try:
                self.logger.info(f"Testing connection {attempt+1}/{retry_count}")
                
                # ØªØ³Øª Ø§ØªØµØ§Ù„ Ø¨Ø§ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø³Ø§Ø¯Ù‡
                self.bot.exchange.exchange.fetch_balance()
                self.logger.info("Connection restored")
                return True
                
            except Exception as e:
                self.logger.warning(f"Connection test failed (attempt {attempt+1}): {str(e)}")
                time.sleep(10 * (attempt + 1))
                
        # Ø§Ú¯Ø± Ø¨Ø¹Ø¯ Ø§Ø² Ú†Ù†Ø¯ Ø¨Ø§Ø± ØªÙ„Ø§Ø´ Ù…ÙˆÙÙ‚ Ù†Ø´Ø¯
        self.bot.telegram.send_alert(
            "ğŸ”´ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØµØ±Ø§ÙÛŒ Ø¨Ø§ Ù…Ø´Ú©Ù„ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª\n\n"
            "Ø±Ø¨Ø§Øª Ø¨Ù‡ Ø·ÙˆØ± Ù…ÙˆÙ‚Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§ ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯"
        )
        self.bot.running = False
        return False
        
    except Exception as e:
        self.logger.error(f"Error handling connection issue: {str(e)}")
        return False

def _handle_market_crash(self, threshold: float = -10.0):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ù‚ÙˆØ· Ø¨Ø§Ø²Ø§Ø±"""
    try:
        # Ø¨Ø±Ø±Ø³ÛŒ ØªØºÛŒÛŒØ±Ø§Øª Ù‚ÛŒÙ…Øª Ø¯Ø± Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
        for symbol in self.bot.config.SYMBOLS:
            ticker = self.bot.exchange.exchange.fetch_ticker(symbol)
            change_24h = ticker['percentage']
            
            if change_24h < threshold:
                # Ø¨Ø³ØªÙ† ØªÙ…Ø§Ù… Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§
                for pos in list(self.bot.exchange.open_positions.keys()):
                    self.bot._close_position(pos, "Ø³Ù‚ÙˆØ· Ø¨Ø§Ø²Ø§Ø±")
                    
                # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ø§Ù†ØªØ¸Ø§Ø±
                self.bot.config.SWING_SETTINGS['pause_trading'] = True
                self.bot.telegram.send_alert(
                    f"âš ï¸ ÙˆØ¶Ø¹ÛŒØª Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø³Ù‚ÙˆØ· Ø¨Ø§Ø²Ø§Ø±\n\n"
                    f"â€¢ Ù†Ù…Ø§Ø¯: {symbol}\n"
                    f"â€¢ ØªØºÛŒÛŒØ± Ù‚ÛŒÙ…Øª 24h: {change_24h:.2f}%\n\n"
                    f"ØªÙ…Ø§Ù… Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù†Ø¯ Ùˆ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¬Ø¯ÛŒØ¯ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯"
                )
                return
                
    except Exception as e:
        self.logger.error(f"Error handling market crash: {str(e)}")

def check_market_health(self):
    """Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù„Ø§Ù…Øª Ú©Ù„ÛŒ Ø¨Ø§Ø²Ø§Ø±"""
    try:
        if self.last_health_check and \
           (datetime.now() - self.last_health_check).total_seconds() < 3600:
            return
            
        self.logger.info("Performing market health check...")
        health_status = {}
        
        # Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø³Ù„Ø§Ù…Øª Ø¨Ø§Ø²Ø§Ø±
        total_volume = 0
        extreme_moves = 0
        symbol_count = len(self.bot.config.SYMBOLS)
        
        for symbol in self.bot.config.SYMBOLS:
            try:
                ticker = self.bot.exchange.exchange.fetch_ticker(symbol)
                ohlcv = self.bot.exchange.get_ohlcv_data(symbol, limit=24)
                
                if ohlcv.empty:
                    continue
                    
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø³Ù„Ø§Ù…Øª
                volume_change = ohlcv['volume'].pct_change().iloc[-1] * 100
                price_change = ohlcv['close'].pct_change().iloc[-1] * 100
                spread = (ticker['ask'] - ticker['bid']) / ticker['ask'] * 100
                
                health_status[symbol] = {
                    'volume_change': volume_change,
                    'price_change': price_change,
                    'spread': spread,
                    'liquidity': ticker['baseVolume']
                }
                
                total_volume += ticker['baseVolume']
                if abs(price_change) > 5:  # ØªØºÛŒÛŒØ±Ø§Øª Ù‚ÛŒÙ…Øª Ø´Ø¯ÛŒØ¯
                    extreme_moves += 1
                    
            except Exception as e:
                self.logger.error(f"Error checking health for {symbol}: {str(e)}")
                continue
                
        # ØªØ¬Ù…ÛŒØ¹ Ù†ØªØ§ÛŒØ¬
        market_health = {
            'timestamp': datetime.now().isoformat(),
            'symbol_health': health_status,
            'total_volume': total_volume,
            'extreme_moves': extreme_moves,
            'extreme_move_ratio': extreme_moves / symbol_count if symbol_count > 0 else 0
        }
        
        self.market_health = market_health
        self.last_health_check = datetime.now()
        
        # ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ù„Ø§Ù…Øª Ø¨Ø§Ø²Ø§Ø±
        if market_health['extreme_move_ratio'] > 0.5:
            self.logger.warning("High market volatility detected!")
            self.bot.telegram.send_alert(
                "âš ï¸ Ù†ÙˆØ³Ø§Ù† Ø¨Ø§Ù„Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯\n\n"
                f"â€¢ ØªØ¹Ø¯Ø§Ø¯ Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ù¾Ø±Ù†ÙˆØ³Ø§Ù†: {extreme_moves}/{symbol_count}\n"
                f"â€¢ Ø­Ø¬Ù… Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±: {total_volume:.2f}\n\n"
                f"Ø±Ø¨Ø§Øª Ø¯Ø± Ø­Ø§Ù„Øª Ù…Ø­Ø§ÙØ¸Ù‡â€ŒÚ©Ø§Ø±Ø§Ù†Ù‡ Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ø§Ø³Øª"
            )
            self.bot.config.SWING_SETTINGS['risk_per_trade'] *= 0.7
            
        self.logger.info("Market health check completed")
        return market_health
        
    except Exception as e:
        self.logger.error(f"Error in market health check: {str(e)}")
        return None
================ 9-MAIN EXECUTION ================
if __name__ == "__main__":
try:
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡ Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ
logger.setup_logging()

    # Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª
    bot = AITradingBot()
    
    # Ø«Ø¨Øª signal handler Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø§ÛŒÙ…Ù†
    def signal_handler(sig, frame):
        bot.logger.info("Received shutdown signal")
        bot.running = False
        bot.telegram.send_alert("ğŸ”´ Ø±Ø¨Ø§Øª Ø¨Ù‡ ØµÙˆØ±Øª Ø§ÛŒÙ…Ù† Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
        sys.exit(0)
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
 # Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª
    bot = AITradingBot()
    
    # Ø«Ø¨Øª signal handler Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø§ÛŒÙ…Ù†
    def signal_handler(sig, frame):
        bot.logger.info("Received shutdown signal")
        bot.running = False
        bot.telegram.send_alert("ğŸ”´ Ø±Ø¨Ø§Øª Ø¨Ù‡ ØµÙˆØ±Øª Ø§ÛŒÙ…Ù† Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
        sys.exit(0)
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
def _setup_data_directory(self) -> str:
    """ØªÙ†Ø¸ÛŒÙ… Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§"""
    data_dir = os.path.join(os.path.dirname(__file__), 'ai_trader_data')
    os.makedirs(data_dir, exist_ok=True)
    
    # Ø§ÛŒØ¬Ø§Ø¯ Ø²ÛŒØ±Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒâ€ŒÙ‡Ø§
    subdirs = ['ohlcv', 'trades', 'models', 'reports']
    for subdir in subdirs:
        os.makedirs(os.path.join(data_dir, subdir), exist_ok=True)
        
    return data_dir

def save_ohlcv_data(self, symbol: str, df: pd.DataFrame):
    """Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OHLCV Ø¨Ù‡ ØµÙˆØ±Øª ÙØ§ÛŒÙ„ Ù¾Ø§Ø±Ú©Øª"""
    try:
        file_path = os.path.join(self.data_dir, 'ohlcv', f'{symbol}.parquet')
        df.to_parquet(file_path, index=True)
        self.logger.debug(f"Saved OHLCV data for {symbol}")
    except Exception as e:
        self.logger.error(f"Error saving OHLCV data: {str(e)}")

def load_ohlcv_data(self, symbol: str) -> pd.DataFrame:
    """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OHLCV"""
    try:
        file_path = os.path.join(self.data_dir, 'ohlcv', f'{symbol}.parquet')
        if os.path.exists(file_path):
            return pd.read_parquet(file_path)
        return pd.DataFrame()
    except Exception as e:
        self.logger.error(f"Error loading OHLCV data: {str(e)}")
        return pd.DataFrame()

def save_trade_history(self, history: list):
    """Ø°Ø®ÛŒØ±Ù‡ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª"""
    try:
        file_path = os.path.join(self.data_dir, 'trades', 'history.json')
        with open(file_path, 'w') as f:
            json.dump(history, f, indent=4, default=str)
    except Exception as e:
        self.logger.error(f"Error saving trade history: {str(e)}")

def load_trade_history(self) -> list:
    """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª"""
    try:
        file_path = os.path.join(self.data_dir, 'trades', 'history.json')
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                return json.load(f)
        return []
    except Exception as e:
        self.logger.error(f"Error loading trade history: {str(e)}")
        return []

def save_model(self, model: TradingModel, version: str):
    """Ø°Ø®ÛŒØ±Ù‡ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†"""
    try:
        file_path = os.path.join(self.data_dir, 'models', f'model_v{version}.joblib')
        joblib.dump(model, file_path)
        self.logger.info(f"Saved model version {version}")
    except Exception as e:
        self.logger.error(f"Error saving model: {str(e)}")

def load_model(self, version: str) -> Optional[TradingModel]:
    """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¯Ù„ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†"""
    try:
        file_path = os.path.join(self.data_dir, 'models', f'model_v{version}.joblib')
        if os.path.exists(file_path):
            return joblib.load(file_path)
        return None
    except Exception as e:
        self.logger.error(f"Error loading model: {str(e)}")
        return None

def generate_report(self, report_type: str = 'daily') -> dict:
    """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    try:
        generator = self.report_generators.get(report_type)
        if generator:
            report = generator()
            self._save_report(report, report_type)
            return report
        raise ValueError(f"Invalid report type: {report_type}")
    except Exception as e:
        self.logger.error(f"Error generating {report_type} report: {str(e)}")
        return {}

def _generate_daily_report(self) -> dict:
    """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡"""
    trade_history = self.load_trade_history()
    today = datetime.now().date()
    
    daily_trades = [
        t for t in trade_history
        if datetime.fromisoformat(t['timestamp']).date() == today
    ]
    
    if not daily_trades:
        return {}
        
    total_trades = len(daily_trades)
    winning_trades = sum(1 for t in daily_trades if t['pnl'] > 0)
    win_rate = (winning_trades / total_trades) * 100 if total_trades > 0 else 0
    total_pnl = sum(t['pnl'] for t in daily_trades)
    
    return {
        'report_type': 'daily',
        'date': today.isoformat(),
        'total_trades': total_trades,
        'winning_trades': winning_trades,
        'win_rate': win_rate,
        'total_pnl': total_pnl,
        'best_trade': max(t['pnl'] for t in daily_trades),
        'worst_trade': min(t['pnl'] for t in daily_trades),
        'trades': daily_trades
    }

def _generate_weekly_report(self) -> dict:
    """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù‡ÙØªÚ¯ÛŒ"""
    trade_history = self.load_trade_history()
    now = datetime.now()
    week_start = now - timedelta(days=now.weekday())
    
    weekly_trades = [
        t for t in trade_history
        if datetime.fromisoformat(t['timestamp']) >= week_start
    ]
    
    if not weekly_trades:
        return {}
        
    # Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ù…Ø´Ø§Ø¨Ù‡ Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡
    total_trades = len(weekly_trades)
    winning_trades = sum(1 for t in weekly_trades if t['pnl'] > 0)
    win_rate = (winning_trades / total_trades) * 100 if total_trades > 0 else 0
    total_pnl = sum(t['pnl'] for t in weekly_trades)
    
    return {
        'report_type': 'weekly',
        'start_date': week_start.date().isoformat(),
        'end_date': now.date().isoformat(),
        'total_trades': total_trades,
        'winning_trades': winning_trades,
        'win_rate': win_rate,
        'total_pnl': total_pnl,
        'best_trade': max(t['pnl'] for t in weekly_trades),
        'worst_trade': min(t['pnl'] for t in weekly_trades),
        'daily_breakdown': self._daily_breakdown(weekly_trades)
    }

def _daily_breakdown(self, trades: list) -> dict:
    """ØªØ¬Ø²ÛŒÙ‡ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡"""
    daily_data = {}
    for trade in trades:
        date = datetime.fromisoformat(trade['timestamp']).date().isoformat()
        if date not in daily_data:
            daily_data[date] = {
                'total_trades': 0,
                'winning_trades': 0,
                'total_pnl': 0
            }
            
        daily_data[date]['total_trades'] += 1
        if trade['pnl'] > 0:
            daily_data[date]['winning_trades'] += 1
        daily_data[date]['total_pnl'] += trade['pnl']
        
    return daily_data

def _save_report(self, report: dict, report_type: str):
    """Ø°Ø®ÛŒØ±Ù‡ Ú¯Ø²Ø§Ø±Ø´ Ø¯Ø± ÙØ§ÛŒÙ„"""
    try:
        if not report:
            return
            
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        file_path = os.path.join(
            self.data_dir, 
            'reports', 
            f'{report_type}_{timestamp}.json'
        )
        
        with open(file_path, 'w') as f:
            json.dump(report, f, indent=4, default=str)
            
        self.logger.info(f"Saved {report_type} report")
    except Exception as e:
        self.logger.error(f"Error saving report: {str(e)}")
 # Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª
    bot = AITradingBot()
    
    # Ø«Ø¨Øª signal handler Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø§ÛŒÙ…Ù†
    def signal_handler(sig, frame):
        bot.logger.info("Received shutdown signal")
        bot.running = False
        bot.telegram.send_alert("ğŸ”´ Ø±Ø¨Ø§Øª Ø¨Ù‡ ØµÙˆØ±Øª Ø§ÛŒÙ…Ù† Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
def calculate_volatility(self, symbol: str, window: int = 14) -> float:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†ÙˆØ³Ø§Ù† (Volatility) Ø¨Ø± Ø§Ø³Ø§Ø³ ATR"""
    try:
        df = self.data_manager.load_ohlcv_data(symbol)
        if df.empty:
            return 0.0
            
        atr = talib.ATR(df['high'], df['low'], df['close'], timeperiod=window)
        return atr.iloc[-1] / df['close'].iloc[-1] * 100  # Ù†ÙˆØ³Ø§Ù† Ø¨Ù‡ Ø¯Ø±ØµØ¯
        
    except Exception as e:
        self.logger.error(f"Error calculating volatility: {str(e)}")
        return 0.0

def detect_market_regime(self, symbol: str) -> str:
    """ØªØ´Ø®ÛŒØµ Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø± (Ø±ÙˆÙ†Ø¯/Ø®Ù†Ø«ÛŒ)"""
    try:
        df = self.data_manager.load_ohlcv_data(symbol)
        if len(df) < 100:
            return "neutral"
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ ADX
        adx = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)
        last_adx = adx.iloc[-1]
        
        if last_adx > 25:  # Ø¨Ø§Ø²Ø§Ø± Ø±ÙˆÙ†Ø¯Ø¯Ø§Ø±
            # ØªØ´Ø®ÛŒØµ Ø¬Ù‡Øª Ø±ÙˆÙ†Ø¯
            ma_50 = talib.SMA(df['close'], timeperiod=50)
            ma_200 = talib.SMA(df['close'], timeperiod=200)
            
            if ma_50.iloc[-1] > ma_200.iloc[-1]:
                return "uptrend"
            else:
                return "downtrend"
        else:
            return "neutral"
            
    except Exception as e:
        self.logger.error(f"Error detecting market regime: {str(e)}")
        return "neutral"

def optimize_strategy_params(self, symbol: str) -> dict:
    """Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø§ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ú˜Ù†ØªÛŒÚ©"""
    try:
        df = self.data_manager.load_ohlcv_data(symbol)
        if len(df) < 1000:
            self.logger.warning("Insufficient data for optimization")
            return {}
            
        # ØªØ§Ø¨Ø¹ fitness Ø¨Ø±Ø§ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ
        def fitness_function(params):
            try:
                rsi_period = int(params[0])
                ma_period = int(params[1])
                atr_multiplier = params[2]
                
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§
                rsi = talib.RSI(df['close'], timeperiod=rsi_period)
                ma = talib.SMA(df['close'], timeperiod=ma_period)
                atr = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)
                
                # Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
                returns = self._simulate_strategy(df, rsi, ma, atr, atr_multiplier)
                sharpe_ratio = returns.mean() / returns.std() * np.sqrt(365)
                
                return sharpe_ratio
                
            except Exception as e:
                self.logger.error(f"Error in fitness calculation: {str(e)}")
                return 0.0
                
        # Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§
        param_ranges = [
            (10, 30),    # RSI period
            (50, 200),   # Moving average period
            (1.5, 3.0)   # ATR multiplier
        ]
        
        # Ø§Ø¬Ø±Ø§ÛŒ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ú˜Ù†ØªÛŒÚ©
        optimizer = GA(
            function=fitness_function,
            dimension=3,
            variable_type='real',
            variable_boundaries=param_ranges
        )
        
        optimizer.run()
        best_params = optimizer.best_variable
        
        return {
            'rsi_period': int(best_params[0]),
            'ma_period': int(best_params[1]),
            'atr_multiplier': best_params[2]
        }
        
    except Exception as e:
        self.logger.error(f"Error in strategy optimization: {str(e)}")
        return {}

def _simulate_strategy(self, df: pd.DataFrame, rsi: pd.Series, 
                      ma: pd.Series, atr: pd.Series, atr_mult: float) -> pd.Series:
    """Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ"""
    signals = pd.Series(0, index=df.index)
    positions = pd.Series(0, index=df.index)
    
    # ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§
    long_cond = (df['close'] > ma) & (rsi < 30)
    short_cond = (df['close'] < ma) & (rsi > 70)
    
    signals[long_cond] = 1
    signals[short_cond] = -1
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ
    entry_price = None
    returns = []
    
    for i in range(1, len(df)):
        if signals.iloc[i] != 0 and positions.iloc[i-1] == 0:
            # ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡
            entry_price = df['close'].iloc[i]
            stop_loss = entry_price - atr.iloc[i] * atr_mult if signals.iloc[i] > 0 \
                       else entry_price + atr.iloc[i] * atr_mult
            positions.iloc[i:] = signals.iloc[i]
            
        elif positions.iloc[i-1] != 0:
            # Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡
            exit_cond = (
                (df['close'].iloc[i] <= stop_loss and positions.iloc[i-1] > 0) or
                (df['close'].iloc[i] >= stop_loss and positions.iloc[i-1] < 0)
            )
            
            if exit_cond or i == len(df)-1:
                exit_price = df['close'].iloc[i]
                trade_return = (exit_price - entry_price) / entry_price * positions.iloc[i-1]
                returns.append(trade_return)
                positions.iloc[i:] = 0
                
    return pd.Series(returns)
def setup(self):
    """Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù†Ù‡Ø§ÛŒÛŒ Ùˆ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡"""
    try:
        self.logger.info("Running final setup...")
        
        # Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù†Ù…Ø§Ø¯
        for symbol in self.config.SYMBOLS:
            optimal_params = self.utils.optimize_strategy_params(symbol)
            if optimal_params:
                self.config.STRATEGY_PARAMS[symbol] = optimal_params
                self.logger.info(f"Optimized params for {symbol}: {optimal_params}")
        
        # Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¯Ù„ Ø§Ø² Ø¯ÛŒØ³Ú© Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯
        saved_model = self.data_manager.load_model('latest')
        if saved_model:
            self.model = saved_model
            self.logger.info("Loaded pre-trained model from disk")
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù„Ø§Ù…Øª Ø¨Ø§Ø²Ø§Ø±
        self.utils.check_market_health()
        
        self.setup_complete = True
        self.logger.info("Setup completed successfully")
        self.telegram.send_alert("âœ… Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ù‡ Ú©Ø§Ø± Ø§Ø³Øª\n\nØªÙ…Ø§Ù… ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯")
        
    except Exception as e:
        self.logger.error(f"Setup failed: {str(e)}")
        raise
    # Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª
    bot = AITradingBot()
    bot.setup()
    
    # Ø«Ø¨Øª signal handler Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø§ÛŒÙ…Ù†
    def signal_handler(sig, frame):
        bot.logger.info("Received shutdown signal")
        
        # ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ
        report = bot.data_manager.generate_report('daily')
        if report:
            bot.telegram.send_alert(
                f"ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ù¾Ø§ÛŒØ§Ù†ÛŒ\n\n"
                f"ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {report['total_trades']}\n"
                f"Ù†Ø±Ø® Ø¨Ø±Ø¯: {report['win_rate']:.1f}%\n"
                f"Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ: {report['total_pnl']:.2f}%\n"
                f"Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: {report['best_trade']:.2f}%\n"
                f"Ø¨Ø¯ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: {report['worst_trade']:.2f}%"
def __init__(self):
    super().__init__()
    self.performance_metrics = {
        'start_date': datetime.now().isoformat(),
        'trade_count': 0,
        'win_rate': 0.0,
        'avg_profit': 0.0,
        'max_drawdown': 0.0
    }
    self._setup_advanced_features()
    
def _setup_advanced_features(self):
    """ØªÙ†Ø¸ÛŒÙ… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ù†Ù‡Ø§ÛŒÛŒ"""
    # ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ Ù¾ÛŒØ´Ø±ÙØªÙ‡
    self.monitor = AdvancedMonitor(
        sample_interval=60,  # Ù‡Ø± 1 Ø¯Ù‚ÛŒÙ‚Ù‡
        max_memory_usage=80,  # 80% Ø­Ø§ÙØ¸Ù‡
        max_cpu_usage=85     # 85% Ù¾Ø±Ø¯Ø§Ø²Ù†Ø¯Ù‡
    )
    
    # ØªÙ†Ø¸ÛŒÙ… Ø³ÛŒØ³ØªÙ… Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±
    self.backup_system = AutoBackup(
        backup_dir='./backups',
        interval=timedelta(hours=6),
        keep_last=5
    )
    
    # ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ… ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ ØªØ·Ø¨ÛŒÙ‚ÛŒ
    self.adaptive_learner = AdaptiveLearningSystem(
        initial_learning_rate=0.001,
        decay_factor=0.99,
        min_learning_rate=0.0001
    )

def shutdown(self):
    """Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª Ø¨Ù‡ ØµÙˆØ±Øª Ø§ÛŒÙ…Ù†"""
    self.logger.info("Starting graceful shutdown...")
    
    try:
        # 1. ØªÙˆÙ‚Ù ØªÙ…Ø§Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…
        self._close_all_positions()
        
        # 2. Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ù…Ø¯Ù„
        self._save_current_state()
        
        # 3. ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ
        self._generate_final_report()
        
        # 4. ØªÙˆÙ‚Ù ØªÙ…Ø§Ù… Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
        self.monitor.stop()
        self.backup_system.stop()
        
        self.logger.info("Shutdown completed successfully")
        self.telegram.send_alert("ğŸ›‘ Ø±Ø¨Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯")
        
    except Exception as e:
        self.logger.error(f"Error during shutdown: {str(e)}")
        self.telegram.send_alert(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª: {str(e)}")

def _close_all_positions(self):
    """Ø¨Ø³ØªÙ† ØªÙ…Ø§Ù… Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²"""
    self.logger.info("Closing all open positions...")
    for symbol in list(self.exchange.open_positions.keys()):
        try:
            self._close_position(symbol, "Shutdown request")
        except Exception as e:
            self.logger.error(f"Failed to close {symbol}: {str(e)}")

def _save_current_state(self):
    """Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ø³ÛŒØ³ØªÙ…"""
    self.logger.info("Saving current state...")
    
    # Ø°Ø®ÛŒØ±Ù‡ Ù…Ø¯Ù„
    self.data_manager.save_model(self.model, 'final')
    
    # Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
    self.config.save_to_file('./config/last_config.json')
    
    # Ø°Ø®ÛŒØ±Ù‡ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    self.exchange.save_trade_history()
    
    # Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ
    self.adaptive_learner.save_state()

def _generate_final_report(self):
    """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù†Ù‡Ø§ÛŒÛŒ"""
    self.logger.info("Generating final performance report...")
    
    report = {
        'performance_metrics': self.performance_metrics,
        'market_analysis': self.utils.check_market_health(),
        'model_performance': {
            'accuracy': self.model.evaluate_current_accuracy(),
            'features': self.model.get_important_features()
        },
        'system_metrics': {
            'uptime': str(datetime.now() - datetime.fromisoformat(self.performance_metrics['start_date'])),
            'resource_usage': self.monitor.get_final_report()
        }
    }
    
    # Ø°Ø®ÛŒØ±Ù‡ Ú¯Ø²Ø§Ø±Ø´
    with open('./reports/final_report.json', 'w') as f:
        json.dump(report, f, indent=4, default=str)
        
    # Ø§Ø±Ø³Ø§Ù„ Ø®Ù„Ø§ØµÙ‡ Ú¯Ø²Ø§Ø±Ø´
    self.telegram.send_alert(
        "ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù†Ù‡Ø§ÛŒÛŒ\n\n"
        f"â± Ø²Ù…Ø§Ù† ÙØ¹Ø§Ù„ÛŒØª: {report['system_metrics']['uptime']}\n"
        f"ğŸ”¢ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {self.performance_metrics['trade_count']}\n"
        f"ğŸ“ˆ Ù†Ø±Ø® Ø¨Ø±Ø¯: {self.performance_metrics['win_rate']:.1f}%\n"
        f"ğŸ’µ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯: {self.performance_metrics['avg_profit']:.2f}%\n"
        f"ğŸ”„ Ø¯Ù‚Øª Ù…Ø¯Ù„: {report['model_performance']['accuracy']*100:.1f}%"
    )
def start(self):
    """Ø´Ø±ÙˆØ¹ Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯"""
    self.running = True
    threading.Thread(target=self._monitor_loop, daemon=True).start()
    
def stop(self):
    """ØªÙˆÙ‚Ù Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯"""
    self.running = False
    
def _monitor_loop(self):
    """Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯"""
    while self.running:
        try:
            # Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ Ù…Ù†Ø§Ø¨Ø¹ Ø³ÛŒØ³ØªÙ…
            mem = psutil.virtual_memory().percent
            cpu = psutil.cpu_percent()
            
            # Ø«Ø¨Øª Ø¯Ø± Ù„Ø§Ú¯
            if mem > self.max_memory * 0.8 or cpu > self.max_cpu * 0.8:
                self.logger.warning(f"High resource usage - CPU: {cpu}%, Mem: {mem}%")
            
            # Ø¨Ø±Ø±Ø³ÛŒ overload
            if mem > self.max_memory or cpu > self.max_cpu:
                self.logger.critical("System overload detected! Initiating emergency protocol")
                self._handle_overload()
                
            time.sleep(self.interval)
            
        except Exception as e:
            self.logger.error(f"Monitoring error: {str(e)}")
            time.sleep(5)

def _handle_overload(self):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø´Ø±Ø§ÛŒØ· Ø§Ø¶Ø§ÙÙ‡ Ø¨Ø§Ø± Ø³ÛŒØ³ØªÙ…"""
    try:
        # 1. Ú©Ø§Ù‡Ø´ Ø§ÙˆÙ„ÙˆÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´
        os.nice(10)
        
        # 2. Ø¢Ø²Ø§Ø¯Ø³Ø§Ø²ÛŒ Ø­Ø§ÙØ¸Ù‡
        gc.collect()
        
        # 3. ØªÙˆÙ‚Ù Ù…ÙˆÙ‚Øª Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ
        # (Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§ Ù…ØªÙˆÙ‚Ù Ú©Ù†ÛŒØ¯)
        
        self.logger.info("System overload handled")
        
    except Exception as e:
        self.logger.error(f"Failed to handle overload: {str(e)}")
def start(self):
    """Ø´Ø±ÙˆØ¹ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ"""
    self.running = True
    threading.Thread(target=self._backup_loop, daemon=True).start()
    
def stop(self):
    """ØªÙˆÙ‚Ù Ø³Ø±ÙˆÛŒØ³ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ"""
    self.running = False
    
def _backup_loop(self):
    """Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ"""
    while self.running:
        try:
            self._perform_backup()
            time.sleep(self.interval.total_seconds())
        except Exception as e:
            self.logger.error(f"Backup failed: {str(e)}")
            time.sleep(60)

def _perform_backup(self):
    """Ø§Ù†Ø¬Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_path = os.path.join(self.backup_dir, f'backup_{timestamp}.zip')
    
    try:
        with zipfile.ZipFile(backup_path, 'w') as zipf:
            # ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù… Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ
            important_files = [
                './config/',
                './ai_trader_data/models/',
                './ai_trader_data/trades/'
            ]
            
            for file in important_files:
                if os.path.isdir
 
